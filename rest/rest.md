# REST
REST (Representational state transfer) was first introduced in [Roy Fielding's doctoral dissertation Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm), and it is described as an _architectural style for distributed hypermedia systems_. It is important to notice two key points here:

1. It is an _architectural style_, not a _protocol_. For example, SOAP is a protocol. REST, on the other side, is an architectural style which make use of standards, but there is no official standard for REST. Because of this, we often find different solutions to a given problem.
2. It is for _distributed hypermedia systems_. Clients have access to hypermedia information from a repository which might be in a distributed network.

In REST, _resources_ (for example, books), can be _represented_ in a variety of forms (namely, XML or JSON). When we talk about _state_, we are referring to the current data of a _resource_. Taking this into account, REST is just a means for two systems to _transfer_ the _state_ of a _resource_ through one of its _representations_.

> Note: we've covered _resource states_. We also have the _application state_, which resides on the client side. It can transition to other states just following the links in the _representations_.

A service which fully adheres to the REST specification is said to be a _RESTful Service_. Also note that, according to Roy's dissertation, _"REST does not restrict communication to a particular protocol"_. Most of the time it is HTTP-based. In such case, we would call it a _RESTful Web Service_.

## Constraints
REST encompasses six constraints:

* **Client-Server** - the principle behind this is the separation of concerns provided by this architectural style.
* **Stateless** - a stateless communication --session state is kept on the client-- leads to _visibility_, _reliability_ and _scalability_.
  * **Visibility** - If we use a visible protocol, like HTTP, other components like a firewall or a proxy, can monitor and collaborate.
* **Cache** - this reduces the number of interactions, which improves the efficiency and thus the user experience.
* **Layered System** - or Microservices. Clients can only see the immediate layer they are interacting with. This layer may be composed of a hiearchy of layers.
* **Code-On-Demand** (optional) - servers can provide clients with executable code (scripts)
* **Uniform Interface** - consists in a common interface to let each side (client and server) to evolve independently. Here is a list of each constraint and how is enforced in a RESTful Web Service:
  * **Identification of resources** - each single resource has an identifier. For this, we use URIs.
  * **Manipulation of resources through representations** - resources state can be manipulated (updated or deleted) by a client using a representation. In RESTful Web Services, the HTTP standard is used.
  * **self-descriptive messages** - each message gives precise information about how to describe itself. The [Media Type (formerly known as MIME types)](https://www.iana.org/assignments/media-types/media-types.xhtml) is used to make messages self-descriptive, for example, using [`application/vnd.api+json`](https://jsonapi.org/).
  * **Hypermedia as the engine of application state (HATEOAS)** - Application state transition are carried out through hypermedia in the resource returned by the server.

## Richardson Maturity Model
The so called [Richardson Maturity Model](https://www.crummy.com/writing/speaking/2008-QCon/act3.html) describes different levels on how RESFull a Web Service is:

* **Level Zero** - One URI and onbe HTTP method. Example: XML-RPC or SOAP.
* **Level One** - Many URIs and one HTTP method.
* **Level Two** - Many URIs and multiple HTTP methods.
* **Level Four** - Hypermedia: leverage links and forms.

## Resources
Resources can be any information that can be named: a document, a collection of documents, a temporal service ("today's weather in Madrid"), etc. There is no consensus about how to model resources, but very often the following patterns are suggested:

#### Document
Represents a single piece of information (like a row in a database), and can be composed of value-fields and links. For example, a specific univerisity, like "Universidad Rey Juan Carlos" can be a _document resource_.

#### Collection
A _collection resource_ is a container of other resources. Clients can request to create a new resource into the collection, but it's up to the server whether to create it or not. The identifier of the resource is generated by the server.

#### Store
As _collections_, _store resources_ works as repositories of resources. But unlike _collections_, the creation of the resource is client-managed, which means the identifier is provided by the client.

#### Controller
_Controller resources_ can be thought as remote methods: they represent an action, accept input parameters and return a value. These can be used to map procedures that do not match any CRUD action, for example to run a number of operations (merge two contacts), or to carry out an operation whose matching CRUD action is not obvious. Each of these resources will have their own identifier to avoid _tunnelling_.

> By tunnelling we mean using the same operation on the same identifier to perform different actions. SOAP over HTTP or XML-RPC are examples of tunnelling, because they use POST calls to a single URI to perform different operations: they both would delete a resource performing a POST call.

## HTTP
When implementing a RESTful Web Service, we will be using HTTP as the underlying transfer protocol. One of the constraints is that the system should be visible. This means we should leverage the available methods of HTTP rather than encapsulating our own methods within our request representations (i.e. we should not do _tunnelling_).

HTTP defines a number of methods along with their description ([RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.1) and [RFC 5789](https://tools.ietf.org/html/rfc5789)):

| Method  | Meaning                                                                             | Is safe | Is idempotent |
|---------|-------------------------------------------------------------------------------------|---------|---------------|
| GET     | Transfer a current representation of the target resource                            | yes     | yes           |
| HEAD    | Same as GET, but only transfer the status line and header section                   | yes     | yes           |
| OPTIONS | Describe the communication options for the target resource                          | yes     | yes           |
| PUT     | Replace all current representations of the target resource with the request payload | no      | yes           |
| DELETE  | Remove all current representations of the target resource                           | no      | yes           |
| POST    | Perform resource-specific processing on the request payload                         | no      | no            |
| PATCH   | Apply partial modifications (delta) to a resource                                   | no      | no            | 

A method is considered _safe_ as long as it does not have side-effects. And it is _idempotent_ when the side-effects of applying several identical requests is the same as for a single request. When maping an API operation to an HTTP method we should consider the semantic of the method, whether the operation is safe or idempotent, how affect caching, etc. From the client point of view, it is not important what HTTP method maps an domain operation.

It's fundamental to notice several things. Neither REST nor HTTP are CRUD. Some HTTP methods clearly map CRUD action (i.e. `GET` maps _Read_ and `DELETE` maps _Delete_). However:

* `POST` can run a number of non-idempotent and unsafe operations. One of those operations might be _Create_. The entire SOAP protocol is _tunnelled_ through `POST`.
* `PUT` does not only _Update_ a resource. It can also _Create_ a specific resource.

REST specification does not mention much about which HTTP methods should be used for a certain operation. This is because REST is all about the architectural style, while HTTP methods are part of the Web's architecture. Because of this, a REST API should not be constrained to only CRUD.

### Verbs
As we've seen, resources have identifiers (URIs), and we can leverage the underlying transfer protocol (namely, HTTP) to modify (for example, using `PUT`) a resource (i.e. change its state) using its representation (for example, a JSON object). It's often said that there is no need for verbs because HTTP already provides them, but this is not accurante: there is no need for verbs because according to REST, we will be transfering a _state_, rather than calling instructions.

### Naming convention in URIs
The REST specification does not state anything about how identifiers ([URI](https://tools.ietf.org/html/rfc3986)) should look like: they are just opaque identifiers. And code need not rely on any URI convention. According to [Roy Fielding words](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven),

> A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API).

So, technically, all these URI might be completely RESTful:

* https://example.com/books/12
* https://example.com/books?getBook=12
* https://example.com/89110c64-0c83-11eb-adc1-0242ac120002

### URI Templates and URI design
Even thoguh according to the REST contraints neither the client nor the documentation should rely on a specific URI convention, that does not mean that we cannot follow a convention to (1) make the URIs human-readable, (2) to save design time or (3) to distribute the processing based on our URIs path. It is completely right to use, for example, [URI Templates RFC 6570](https://tools.ietf.org/html/rfc6570).

Many of the rules on how to design URIs are opinionated. Still, some have major approval in the community, like the ones presented in [REST API Design Rulebook, by Mark Masse](https://learning.oreilly.com/library/view/rest-api-design/9781449317904/).

### URI Format
* Forward slash (/): won't be used as the last character of a URI. It is used to specify a hierarchical relationship.
* Use hyphens (-), and not underscore (_), to improve readability.
* Use lowercase.
* Do not include file extensions. Use the HTTP `Accept` header instead.

### URI Archetypes
There is almost a consensus about whether to use plural or singular names:

#### Document
Use a singular noun:

```
https://example.com/universities/urjc
https://example.com/univerisities/urjc/masters/cloud-computing
https://example.com/univerisities/urjc/masters/cloud-computing/subjects/api-design
```

#### Collection and store
Use a singular noun:

```
https://example.com/universities
https://example.com/univerisities/urjc/masters
https://example.com/univerisities/urjc/masters/cloud-computing/subjects
```

#### Controller
Use a verb:

```
https://example.com/albums/341/play
POST https://example.com/products/51240/discountoffer
```

### HATEOAS
We want to leverage hypermedia turn our service into a states machine. The state is the resource itself. To change the state we will use hyperlinks. There is no unique medium to express them:

* HTTP: [Web Links (RFC 8288)](https://tools.ietf.org/html/rfc8288) - Send links through the HTTP headers. Apropriate when the representation does not allow links (i.e. an image or a plain text) or when it's required to read links without parsing the body.
* JSON: [JSON-LD](https://json-ld.org/), [HAL (Hypertext Application Language)](https://tools.ietf.org/html/draft-kelly-json-hal-08) or [Hydra](http://www.hydra-cg.com/spec/latest/core/).
* XML: [Atom (RFC 5023)](https://tools.ietf.org/html/rfc5023#section-11).

To generate a state machine we can think in a microwave oven. When we first get it, it might returns to turn it on:

```
GET /microwaves/12

{
    "state": "off",
    "actions": [
        {
            "rel": "on",
            "href": "/microwaves/12",
            "method": "PUT",
            "Expects": { "state": "on"}
        }
    ]
}
```

Then, following the `on` link, the microwave would be turned on.

### Querying URI
Queries are used to filter, sort and paginate both collections and stores. Brackets or colon might be handy to use operators:

* Get all: `GET /universities`.
* Basic filtering. Select those whose `country` is `spain`: `GET /universities?country=spain`.
* Filtering with operand: Select those whose `country` is not equal to `spain`: `GET /universities?country[neq]=spain`.
* Sorting: `GET /universities?sort_by=-date,id`.
* Select specific fields: `GET /universities?fields=id,name,departments(name)`. Example: [Google Tasks API](https://developers.google.com/tasks/performance#partial-response).

#### Pagination
We tyipically identify two different pagination mechanisms:
* Offset-based pagination: `GET /universities?limit=10&offset=30`.
* [Cursor-based pagination](https://developers.facebook.com/docs/graph-api/using-graph-api/#paging): `GET /universities?limit=10&next=uc3m`.

_Cursor-based_ pagination is more popular nowadays.

It can also contain `Web Links` headers to help traversing a collection of resources. See for example the [GitHub API](https://developer.github.com/v3/#pagination).

## Error messages and error responses
TODO: There are greys: /departments/:deptID/employees?name=Smith. If there is no employee named Smith for the given department, a 404 looks fine. What if there is no :deptID department? What should we return?

## Versioning
When it comes to versioning, according to [Roy Fielding keynote on Evolve'13](https://www.slideshare.net/evolve_conference/201308-fielding-evolve), the best practice for versioning a REST API is not to version it. REST is already defined as a state machine (HATEOAS) where each state can be dynamic and each transition can be redirected (linked). So instead of agreeing on an interface, to change the state, client software should only need to _follow_ the apropriate links (as we humans do when we use a web).

To read: https://nordicapis.com/api-change-strategy/
